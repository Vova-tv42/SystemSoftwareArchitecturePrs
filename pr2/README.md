# Лабораторна робота №2

## Опис проєкту
Ця робота присвячена дослідженню структури віртуального адресного простору процесу в ОС Linux, аналізу сегментів виконуваного файлу (Text, Data, BSS), вивченню напрямку росту стеку та розв'язанню проблеми переповнення типу `time_t`.

## Склад проєкту
- `segments_investigation.c` - програма для порівняння сегментів BSS та Data (Варіант 9).
- `memory.c` - програма для аналізу адрес сегментів, стеку, купи та симуляції проблеми Y2038.
- `app.sh` - Bash-скрипт для автоматизації компіляції та запуску програм.

## Інструкція з запуску
Для проведення всіх досліджень виконайте скрипт:
```bash
./app.sh
```

## Результати виконання завдань

### 1. Загальне завдання (Аналіз часу та сегментів)
- **Проблема 2038 року:** Встановлено, що в 32-бітних системах тип `time_t` має розмір 4 байти. При досягненні значення `0x7FFFFFFF` (19 січня 2038 року) стається переповнення, що призводить до некоректного відображення дати (повернення до 1901 або 1970 року). На 64-бітних системах розмір `time_t` становить 8 байт, що відтерміновує цю проблему на мільярди років.
- **Сегменти:** Програма успішно вивела адреси основних сегментів. Адреси функцій знаходяться в сегменті Text, глобальні змінні - у Data/BSS, динамічна пам'ять - у Heap, а локальні змінні - у Stack.

### 2. Завдання 2.2 (Дослідження сегментів)
- **BSS проти Data:** Експериментально підтверджено, що неініціалізовані глобальні масиви (BSS) не займають місця у виконуваному файлі на диску, зберігаючи лише інформацію про необхідний розмір. Ініціалізовані масиви (Data) збільшують розмір файлу пропорційно своєму об'єму.
- **Локальні масиви:** Оголошення великих масивів всередині функцій не впливає на розмір файлу `a.out`, оскільки місце для них виділяється динамічно у стеку під час виконання програми.
- **Вплив компіляції:** Використання прапорця `-g` для налагодження значно збільшує розмір файлу через додавання таблиці символів, тоді як прапорці оптимізації (наприклад, `-O3`) можуть зменшити розмір сегмента Text.

### 3. Завдання 2.3 (Дослідження стеку)
- Шляхом рекурсивного виклику функції та виводу адрес локальних змінних встановлено, що в системі Linux на архітектурі x86_64 стек росте в сторону зменшення адрес (зверху вниз). Кожен наступний рівень рекурсії має меншу адресу, ніж попередній.

### 4. Завдання 2.4 (Аналіз стеку через GDB/gstack)
- Виконання цього завдання у запропонований спосіб виявилося неможливим на сучасній системі Ubuntu. Утиліта `gstack` та старі методи підключення до процесів через GDB є застарілими. Через обмеження безпеки сучасних ядер Linux (зокрема параметри `ptrace_scope`) та зміни в архітектурі системних пакунків, ці інструменти більше не працюють у форматі, описаному в завданні.

### 5. Завдання 2.5 (Робота з пам'яттю)
- Процесор використовує стек для збереження адрес повернення при виклику процедур. Теоретично можна обійтися без лічильника команд (IP), використовуючи лише стек, але це значно ускладнило б логіку переходів та продуктивність процесора, оскільки IP забезпечує послідовну вибірку інструкцій незалежно від стану даних у стеку.

### 6. Варіант 9: Використання BSS для великих масивів
- Результати тестування `segments_investigation.c` показали, що використання сегмента BSS є критично важливим для оптимізації розміру дистрибутивів програм. Масив на 1 000 000 елементів у сегменті BSS залишає файл розміром близько 16 КБ, тоді як ініціалізований масив збільшує його до 4 МБ.

## Журнал вирішення проблем
1. **Помилка відображення Y2038:** На 64-бітній системі переповнення `time_t` не відбувалося природним шляхом. Проблему вирішено через симуляцію з використанням типу `int32_t`, що дозволило продемонструвати логіку переповнення незалежно від архітектури.
2. **Застарілість інструментів:** Проблема з виконанням завдання 2.4 - інструменти застарілі.
